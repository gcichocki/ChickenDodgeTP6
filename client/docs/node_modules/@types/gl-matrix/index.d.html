<!DOCTYPE html>

<html>
<head>
  <title>index.d.ts</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="index.d.html">
                      node_modules/@types/gl-matrix/index.d.ts
                </a>
              
                
                <a class="source" href="../text-encoding/index.d.html">
                      node_modules/@types/text-encoding/index.d.ts
                </a>
              
                
                <a class="source" href="../../../src/chickendodge.html">
                      src/chickendodge.ts
                </a>
              
                
                <a class="source" href="../../../src/components.html">
                      src/components.ts
                </a>
              
                
                <a class="source" href="../../../src/components/audioComponent.html">
                      src/components/audioComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/backgroundLoaderComponent.html">
                      src/components/backgroundLoaderComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/cameraComponent.html">
                      src/components/cameraComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/chickenComponent.html">
                      src/components/chickenComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/chickenSpawnerComponent.html">
                      src/components/chickenSpawnerComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/colliderComponent.html">
                      src/components/colliderComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/component.html">
                      src/components/component.ts
                </a>
              
                
                <a class="source" href="../../../src/components/compositorComponent.html">
                      src/components/compositorComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/countdownComponent.html">
                      src/components/countdownComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/debugDrawCallsComponent.html">
                      src/components/debugDrawCallsComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/deformationCompositorComponent.html">
                      src/components/deformationCompositorComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/enablerComponent.html">
                      src/components/enablerComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/heartComponent.html">
                      src/components/heartComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/inputComponent.html">
                      src/components/inputComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/layerComponent.html">
                      src/components/layerComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/lifeComponent.html">
                      src/components/lifeComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/playerComponent.html">
                      src/components/playerComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/positionComponent.html">
                      src/components/positionComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/rawSpriteComponent.html">
                      src/components/rawSpriteComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/rectangle.html">
                      src/components/rectangle.ts
                </a>
              
                
                <a class="source" href="../../../src/components/refereeComponent.html">
                      src/components/refereeComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/renderCompositorComponent.html">
                      src/components/renderCompositorComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/rupeeComponent.html">
                      src/components/rupeeComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/scoreComponent.html">
                      src/components/scoreComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/spriteComponent.html">
                      src/components/spriteComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/spriteSheetComponent.html">
                      src/components/spriteSheetComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/textSpriteComponent.html">
                      src/components/textSpriteComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/textureComponent.html">
                      src/components/textureComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/components/timerComponent.html">
                      src/components/timerComponent.ts
                </a>
              
                
                <a class="source" href="../../../src/displaySystem.html">
                      src/displaySystem.ts
                </a>
              
                
                <a class="source" href="../../../src/entity.html">
                      src/entity.ts
                </a>
              
                
                <a class="source" href="../../../src/eventTrigger.html">
                      src/eventTrigger.ts
                </a>
              
                
                <a class="source" href="../../../src/graphicsAPI.html">
                      src/graphicsAPI.ts
                </a>
              
                
                <a class="source" href="../../../src/localisation.html">
                      src/localisation.ts
                </a>
              
                
                <a class="source" href="../../../src/logicSystem.html">
                      src/logicSystem.ts
                </a>
              
                
                <a class="source" href="../../../src/main.html">
                      src/main.ts
                </a>
              
                
                <a class="source" href="../../../src/scene.html">
                      src/scene.ts
                </a>
              
                
                <a class="source" href="../../../src/sceneMgrSystem.html">
                      src/sceneMgrSystem.ts
                </a>
              
                
                <a class="source" href="../../../src/system.html">
                      src/system.ts
                </a>
              
                
                <a class="source" href="../../../src/timing.html">
                      src/timing.ts
                </a>
              
                
                <a class="source" href="../../../src/utils.html">
                      src/utils.ts
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>index.d.ts</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Type definitions for gl-matrix 2.4
Project: <a href="https://github.com/toji/gl-matrix">https://github.com/toji/gl-matrix</a>
Definitions by: Mattijs Kneppers <a href="https://github.com/mattijskneppers">https://github.com/mattijskneppers</a>, based on definitions by Tat <a href="https://github.com/tatchx">https://github.com/tatchx</a>
                Nikolay Babanov <a href="https://github.com/nbabanov">https://github.com/nbabanov</a>
                Austin Martin <a href="https://github.com/auzmartist">https://github.com/auzmartist</a>
                Wayne Langman <a href="https://github.com/surtr-isaz">https://github.com/surtr-isaz</a>
Definitions: <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix' {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Global Utilities</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> glMatrix {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Configuration constants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EPSILON: <span class="hljs-built_in">number</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ARRAY_TYPE: <span class="hljs-built_in">any</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RANDOM(): <span class="hljs-built_in">number</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ENABLE_SIMD: <span class="hljs-built_in">boolean</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Compatibility detection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SIMD_AVAILABLE: <span class="hljs-built_in">boolean</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> USE_SIMD: <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Sets the type of array used when creating new vectors and matrices
         *
         * @param {any} type - Array type, such as Float32Array or Array
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> setMatrixArrayType(<span class="hljs-keyword">type</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span>;

        <span class="hljs-comment">/**
         * Convert Degree To Radian
         *
         * @param {number} a - Angle in Degrees
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> toRadian(a: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Tests whether or not the arguments have approximately the same value, within an absolute
         * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
         * than or equal to 1.0, and a relative tolerance is used for larger values)
         *
         * @param {number} a - The first number to test.
         * @param {number} b - The second number to test.
         * @returns {boolean} True if the numbers are approximately equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals(a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>vec2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> vec2 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeVec2: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new, empty vec2
         *
         * @returns a new 2D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): vec2;

        <span class="hljs-comment">/**
         * Creates a new vec2 initialized with values from an existing vector
         *
         * @param a a vector to clone
         * @returns a new 2D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Creates a new vec2 initialized with the given values
         *
         * @param x X component
         * @param y Y component
         * @returns a new 2D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>): vec2;

        <span class="hljs-comment">/**
         * Copy the values from one vec2 to another
         *
         * @param out the receiving vector
         * @param a the source vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Set the components of a vec2 to the given values
         *
         * @param out the receiving vector
         * @param x X component
         * @param y Y component
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span>(out: vec2, x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>): vec2;

        <span class="hljs-comment">/**
         * Adds two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Subtracts vector b from vector a
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> subtract(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Subtracts vector b from vector a
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sub(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Multiplies two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Multiplies two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Divides two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> divide(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Divides two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> div(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Math.ceil the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to ceil
         * @returns {vec2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ceil(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Math.floor the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to floor
         * @returns {vec2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> floor (out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Returns the minimum of two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> min(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Returns the maximum of two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> max(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Math.round the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to round
         * @returns {vec2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> round(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;


        <span class="hljs-comment">/**
         * Scales a vec2 by a scalar number
         *
         * @param out the receiving vector
         * @param a the vector to scale
         * @param b amount to scale the vector by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: <span class="hljs-built_in">number</span>): vec2;

        <span class="hljs-comment">/**
         * Adds two vec2's after scaling the second operand by a scalar value
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @param scale the amount to scale b by before adding
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scaleAndAdd(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[], scale: <span class="hljs-built_in">number</span>): vec2;

        <span class="hljs-comment">/**
         * Calculates the euclidian distance between two vec2's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> distance(a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the euclidian distance between two vec2's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> dist(a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared euclidian distance between two vec2's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns squared distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> squaredDistance(a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared euclidian distance between two vec2's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns squared distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqrDist(a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the length of a vec2
         *
         * @param a vector to calculate length of
         * @returns length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> length(a: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the length of a vec2
         *
         * @param a vector to calculate length of
         * @returns length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> len(a: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a vec2
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> squaredLength(a: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a vec2
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqrLen(a: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Negates the components of a vec2
         *
         * @param out the receiving vector
         * @param a vector to negate
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> negate(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Returns the inverse of the components of a vec2
         *
         * @param out the receiving vector
         * @param a vector to invert
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> inverse(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Normalize a vec2
         *
         * @param out the receiving vector
         * @param a vector to normalize
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> normalize(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Calculates the dot product of two vec2's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns dot product of a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> dot(a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Computes the cross product of two vec2's
         * Note that the cross product must by definition produce a 3D vector
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> cross(out: vec3, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): vec2;

        <span class="hljs-comment">/**
         * Performs a linear interpolation between two vec2's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @param t interpolation amount between the two inputs
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lerp(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[], t: <span class="hljs-built_in">number</span>): vec2;

        <span class="hljs-comment">/**
         * Generates a random unit vector
         *
         * @param out the receiving vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> random(out: vec2): vec2;

        <span class="hljs-comment">/**
         * Generates a random vector with the given scale
         *
         * @param out the receiving vector
         * @param scale Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> random(out: vec2, scale: <span class="hljs-built_in">number</span>): vec2;

        <span class="hljs-comment">/**
         * Transforms the vec2 with a mat2
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param m matrix to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformMat2(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], m: mat2): vec2;

        <span class="hljs-comment">/**
         * Transforms the vec2 with a mat2d
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param m matrix to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformMat2d(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], m: mat2d): vec2;

        <span class="hljs-comment">/**
         * Transforms the vec2 with a mat3
         * 3rd vector component is implicitly '1'
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param m matrix to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformMat3(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], m: mat3): vec2;

        <span class="hljs-comment">/**
         * Transforms the vec2 with a mat4
         * 3rd vector component is implicitly '0'
         * 4th vector component is implicitly '1'
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param m matrix to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformMat4(out: vec2, a: vec2 | <span class="hljs-built_in">number</span>[], m: mat4): vec2;

        <span class="hljs-comment">/**
         * Perform some operation over an array of vec2s.
         *
         * @param a the array of vectors to iterate over
         * @param stride Number of elements between the start of each vec2. If 0 assumes tightly packed
         * @param offset Number of elements to skip at the beginning of the array
         * @param count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param fn Function to call for each vector in the array
         * @param arg additional argument to pass to fn
         * @returns a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> forEach(a: <span class="hljs-built_in">Float32Array</span>, stride: <span class="hljs-built_in">number</span>, offset: <span class="hljs-built_in">number</span>, count: <span class="hljs-built_in">number</span>,
                              fn: <span class="hljs-function">(<span class="hljs-params">a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[], arg: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>, arg: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">Float32Array</span>;

        <span class="hljs-comment">/**
         * Perform some operation over an array of vec2s.
         *
         * @param a the array of vectors to iterate over
         * @param stride Number of elements between the start of each vec2. If 0 assumes tightly packed
         * @param offset Number of elements to skip at the beginning of the array
         * @param count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param fn Function to call for each vector in the array
         * @returns a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> forEach(a: <span class="hljs-built_in">Float32Array</span>, stride: <span class="hljs-built_in">number</span>, offset: <span class="hljs-built_in">number</span>, count: <span class="hljs-built_in">number</span>,
                              fn: <span class="hljs-function">(<span class="hljs-params">a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">Float32Array</span>;

        <span class="hljs-comment">/**
         * Returns a string representation of a vector
         *
         * @param a vector to represent as a string
         * @returns string representation of the vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(a: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
         *
         * @param {vec2} a The first vector.
         * @param {vec2} b The second vector.
         * @returns {boolean} True if the vectors are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals (a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the vectors have approximately the same elements in the same position.
         *
         * @param {vec2} a The first vector.
         * @param {vec2} b The second vector.
         * @returns {boolean} True if the vectors are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals (a: vec2 | <span class="hljs-built_in">number</span>[], b: vec2 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">boolean</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>vec3</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> vec3 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeVec3: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new, empty vec3
         *
         * @returns a new 3D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): vec3;

        <span class="hljs-comment">/**
         * Creates a new vec3 initialized with values from an existing vector
         *
         * @param a vector to clone
         * @returns a new 3D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Creates a new vec3 initialized with the given values
         *
         * @param x X component
         * @param y Y component
         * @param z Z component
         * @returns a new 3D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Copy the values from one vec3 to another
         *
         * @param out the receiving vector
         * @param a the source vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Set the components of a vec3 to the given values
         *
         * @param out the receiving vector
         * @param x X component
         * @param y Y component
         * @param z Z component
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span>(out: vec3, x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Adds two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Subtracts vector b from vector a
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> subtract(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Subtracts vector b from vector a
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sub(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3

        <span class="hljs-comment">/**
         * Multiplies two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Multiplies two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Divides two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> divide(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Divides two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> div(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Math.ceil the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to ceil
         * @returns {vec3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ceil (out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Math.floor the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to floor
         * @returns {vec3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> floor (out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Returns the minimum of two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> min(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Returns the maximum of two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> max(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Math.round the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to round
         * @returns {vec3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> round (out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[]): vec3

        <span class="hljs-comment">/**
         * Scales a vec3 by a scalar number
         *
         * @param out the receiving vector
         * @param a the vector to scale
         * @param b amount to scale the vector by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Adds two vec3's after scaling the second operand by a scalar value
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @param scale the amount to scale b by before adding
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scaleAndAdd(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], scale: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Calculates the euclidian distance between two vec3's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> distance(a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the euclidian distance between two vec3's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> dist(a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared euclidian distance between two vec3's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns squared distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> squaredDistance(a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared euclidian distance between two vec3's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns squared distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqrDist(a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the length of a vec3
         *
         * @param a vector to calculate length of
         * @returns length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> length(a: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the length of a vec3
         *
         * @param a vector to calculate length of
         * @returns length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> len(a: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a vec3
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> squaredLength(a: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a vec3
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqrLen(a: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Negates the components of a vec3
         *
         * @param out the receiving vector
         * @param a vector to negate
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> negate(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Returns the inverse of the components of a vec3
         *
         * @param out the receiving vector
         * @param a vector to invert
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> inverse(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Normalize a vec3
         *
         * @param out the receiving vector
         * @param a vector to normalize
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> normalize(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Calculates the dot product of two vec3's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns dot product of a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> dot(a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Computes the cross product of two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> cross(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): vec3;

        <span class="hljs-comment">/**
         * Performs a linear interpolation between two vec3's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @param t interpolation amount between the two inputs
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lerp(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], t: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Performs a hermite interpolation with two control points
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @param {vec3} c the third operand
         * @param {vec3} d the fourth operand
         * @param {number} t interpolation amount between the two inputs
         * @returns {vec3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> hermite (out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], c: vec3 | <span class="hljs-built_in">number</span>[], d: vec3 | <span class="hljs-built_in">number</span>[], t: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Performs a bezier interpolation with two control points
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @param {vec3} c the third operand
         * @param {vec3} d the fourth operand
         * @param {number} t interpolation amount between the two inputs
         * @returns {vec3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> bezier (out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], c: vec3 | <span class="hljs-built_in">number</span>[], d: vec3 | <span class="hljs-built_in">number</span>[], t: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Generates a random unit vector
         *
         * @param out the receiving vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> random(out: vec3): vec3;

        <span class="hljs-comment">/**
         * Generates a random vector with the given scale
         *
         * @param out the receiving vector
         * @param [scale] Length of the resulting vector. If omitted, a unit vector will be returned
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> random(out: vec3, scale: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Transforms the vec3 with a mat3.
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param m the 3x3 matrix to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformMat3(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], m: mat3): vec3;

        <span class="hljs-comment">/**
         * Transforms the vec3 with a mat4.
         * 4th vector component is implicitly '1'
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param m matrix to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformMat4(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], m: mat4): vec3;

         <span class="hljs-comment">/**
         * Transforms the vec3 with a quat
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param q quaternion to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformQuat(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], q: quat): vec3;


        <span class="hljs-comment">/**
         * Rotate a 3D vector around the x-axis
         * @param out The receiving vec3
         * @param a The vec3 point to rotate
         * @param b The origin of the rotation
         * @param c The angle of rotation
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateX(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], c: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Rotate a 3D vector around the y-axis
         * @param out The receiving vec3
         * @param a The vec3 point to rotate
         * @param b The origin of the rotation
         * @param c The angle of rotation
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateY(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], c: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Rotate a 3D vector around the z-axis
         * @param out The receiving vec3
         * @param a The vec3 point to rotate
         * @param b The origin of the rotation
         * @param c The angle of rotation
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateZ(out: vec3, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], c: <span class="hljs-built_in">number</span>): vec3;

        <span class="hljs-comment">/**
         * Perform some operation over an array of vec3s.
         *
         * @param a the array of vectors to iterate over
         * @param stride Number of elements between the start of each vec3. If 0 assumes tightly packed
         * @param offset Number of elements to skip at the beginning of the array
         * @param count Number of vec3s to iterate over. If 0 iterates over entire array
         * @param fn Function to call for each vector in the array
         * @param arg additional argument to pass to fn
         * @returns a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> forEach(a: <span class="hljs-built_in">Float32Array</span>, stride: <span class="hljs-built_in">number</span>, offset: <span class="hljs-built_in">number</span>, count: <span class="hljs-built_in">number</span>,
                              fn: <span class="hljs-function">(<span class="hljs-params">a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[], arg: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>, arg: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">Float32Array</span>;

        <span class="hljs-comment">/**
         * Perform some operation over an array of vec3s.
         *
         * @param a the array of vectors to iterate over
         * @param stride Number of elements between the start of each vec3. If 0 assumes tightly packed
         * @param offset Number of elements to skip at the beginning of the array
         * @param count Number of vec3s to iterate over. If 0 iterates over entire array
         * @param fn Function to call for each vector in the array
         * @returns a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> forEach(a: <span class="hljs-built_in">Float32Array</span>, stride: <span class="hljs-built_in">number</span>, offset: <span class="hljs-built_in">number</span>, count: <span class="hljs-built_in">number</span>,
                              fn: <span class="hljs-function">(<span class="hljs-params">a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">Float32Array</span>;

        <span class="hljs-comment">/**
         * Get the angle between two 3D vectors
         * @param a The first operand
         * @param b The second operand
         * @returns The angle in radians
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> angle(a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Returns a string representation of a vector
         *
         * @param a vector to represent as a string
         * @returns string representation of the vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(a: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
         *
         * @param {vec3} a The first vector.
         * @param {vec3} b The second vector.
         * @returns {boolean} True if the vectors are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals (a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">boolean</span>

        <span class="hljs-comment">/**
         * Returns whether or not the vectors have approximately the same elements in the same position.
         *
         * @param {vec3} a The first vector.
         * @param {vec3} b The second vector.
         * @returns {boolean} True if the vectors are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals (a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">boolean</span>
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>vec4</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> vec4 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeVec3: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new, empty vec4
         *
         * @returns a new 4D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): vec4;

        <span class="hljs-comment">/**
         * Creates a new vec4 initialized with values from an existing vector
         *
         * @param a vector to clone
         * @returns a new 4D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Creates a new vec4 initialized with the given values
         *
         * @param x X component
         * @param y Y component
         * @param z Z component
         * @param w W component
         * @returns a new 4D vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span>, w: <span class="hljs-built_in">number</span>): vec4;

        <span class="hljs-comment">/**
         * Copy the values from one vec4 to another
         *
         * @param out the receiving vector
         * @param a the source vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Set the components of a vec4 to the given values
         *
         * @param out the receiving vector
         * @param x X component
         * @param y Y component
         * @param z Z component
         * @param w W component
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span>(out: vec4, x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span>, w: <span class="hljs-built_in">number</span>): vec4;

        <span class="hljs-comment">/**
         * Adds two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Subtracts vector b from vector a
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> subtract(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Subtracts vector b from vector a
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sub(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Multiplies two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Multiplies two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Divides two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> divide(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Divides two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> div(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Math.ceil the components of a vec4
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a vector to ceil
         * @returns {vec4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ceil (out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Math.floor the components of a vec4
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a vector to floor
         * @returns {vec4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> floor (out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Returns the minimum of two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> min(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Returns the maximum of two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> max(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Math.round the components of a vec4
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a vector to round
         * @returns {vec4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> round (out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Scales a vec4 by a scalar number
         *
         * @param out the receiving vector
         * @param a the vector to scale
         * @param b amount to scale the vector by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: <span class="hljs-built_in">number</span>): vec4;

        <span class="hljs-comment">/**
         * Adds two vec4's after scaling the second operand by a scalar value
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @param scale the amount to scale b by before adding
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scaleAndAdd(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[], scale: <span class="hljs-built_in">number</span>): vec4;

        <span class="hljs-comment">/**
         * Calculates the euclidian distance between two vec4's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> distance(a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the euclidian distance between two vec4's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> dist(a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared euclidian distance between two vec4's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns squared distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> squaredDistance(a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared euclidian distance between two vec4's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns squared distance between a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqrDist(a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the length of a vec4
         *
         * @param a vector to calculate length of
         * @returns length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> length(a: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the length of a vec4
         *
         * @param a vector to calculate length of
         * @returns length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> len(a: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a vec4
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> squaredLength(a: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a vec4
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqrLen(a: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Negates the components of a vec4
         *
         * @param out the receiving vector
         * @param a vector to negate
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> negate(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Returns the inverse of the components of a vec4
         *
         * @param out the receiving vector
         * @param a vector to invert
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> inverse(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Normalize a vec4
         *
         * @param out the receiving vector
         * @param a vector to normalize
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> normalize(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[]): vec4;

        <span class="hljs-comment">/**
         * Calculates the dot product of two vec4's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns dot product of a and b
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> dot(a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Performs a linear interpolation between two vec4's
         *
         * @param out the receiving vector
         * @param a the first operand
         * @param b the second operand
         * @param t interpolation amount between the two inputs
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lerp(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[], t: <span class="hljs-built_in">number</span>): vec4;

        <span class="hljs-comment">/**
         * Generates a random unit vector
         *
         * @param out the receiving vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> random(out: vec4): vec4;

        <span class="hljs-comment">/**
         * Generates a random vector with the given scale
         *
         * @param out the receiving vector
         * @param scale length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> random(out: vec4, scale: <span class="hljs-built_in">number</span>): vec4;

        <span class="hljs-comment">/**
         * Transforms the vec4 with a mat4.
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param m matrix to transform with
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformMat4(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], m: mat4): vec4;

        <span class="hljs-comment">/**
         * Transforms the vec4 with a quat
         *
         * @param out the receiving vector
         * @param a the vector to transform
         * @param q quaternion to transform with
         * @returns out
         */</span>

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transformQuat(out: vec4, a: vec4 | <span class="hljs-built_in">number</span>[], q: quat): vec4;

        <span class="hljs-comment">/**
         * Perform some operation over an array of vec4s.
         *
         * @param a the array of vectors to iterate over
         * @param stride Number of elements between the start of each vec4. If 0 assumes tightly packed
         * @param offset Number of elements to skip at the beginning of the array
         * @param count Number of vec4s to iterate over. If 0 iterates over entire array
         * @param fn Function to call for each vector in the array
         * @param arg additional argument to pass to fn
         * @returns a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> forEach(a: <span class="hljs-built_in">Float32Array</span>, stride: <span class="hljs-built_in">number</span>, offset: <span class="hljs-built_in">number</span>, count: <span class="hljs-built_in">number</span>,
                              fn: <span class="hljs-function">(<span class="hljs-params">a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[], arg: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>, arg: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">Float32Array</span>;

        <span class="hljs-comment">/**
         * Perform some operation over an array of vec4s.
         *
         * @param a the array of vectors to iterate over
         * @param stride Number of elements between the start of each vec4. If 0 assumes tightly packed
         * @param offset Number of elements to skip at the beginning of the array
         * @param count Number of vec4s to iterate over. If 0 iterates over entire array
         * @param fn Function to call for each vector in the array
         * @returns a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> forEach(a: <span class="hljs-built_in">Float32Array</span>, stride: <span class="hljs-built_in">number</span>, offset: <span class="hljs-built_in">number</span>, count: <span class="hljs-built_in">number</span>,
                              fn: <span class="hljs-function">(<span class="hljs-params">a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">Float32Array</span>;

        <span class="hljs-comment">/**
         * Returns a string representation of a vector
         *
         * @param a vector to represent as a string
         * @returns string representation of the vector
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(a: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
         *
         * @param {vec4} a The first vector.
         * @param {vec4} b The second vector.
         * @returns {boolean} True if the vectors are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals (a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the vectors have approximately the same elements in the same position.
         *
         * @param {vec4} a The first vector.
         * @param {vec4} b The second vector.
         * @returns {boolean} True if the vectors are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals (a: vec4 | <span class="hljs-built_in">number</span>[], b: vec4 | <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">boolean</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>mat2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> mat2 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeMat2: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new identity mat2
         *
         * @returns a new 2x2 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): mat2;

        <span class="hljs-comment">/**
         * Creates a new mat2 initialized with values from an existing matrix
         *
         * @param a matrix to clone
         * @returns a new 2x2 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: mat2): mat2;

        <span class="hljs-comment">/**
         * Copy the values from one mat2 to another
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: mat2, a: mat2): mat2;

        <span class="hljs-comment">/**
         * Set a mat2 to the identity matrix
         *
         * @param out the receiving matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identity(out: mat2): mat2;

        <span class="hljs-comment">/**
         * Create a new mat2 with the given values
         *
         * @param {number} m00 Component in column 0, row 0 position (index 0)
         * @param {number} m01 Component in column 0, row 1 position (index 1)
         * @param {number} m10 Component in column 1, row 0 position (index 2)
         * @param {number} m11 Component in column 1, row 1 position (index 3)
         * @returns {mat2} out A new 2x2 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues(m00: <span class="hljs-built_in">number</span>, m01: <span class="hljs-built_in">number</span>, m10: <span class="hljs-built_in">number</span>, m11: <span class="hljs-built_in">number</span>): mat2;

        <span class="hljs-comment">/**
         * Set the components of a mat2 to the given values
         *
         * @param {mat2} out the receiving matrix
         * @param {number} m00 Component in column 0, row 0 position (index 0)
         * @param {number} m01 Component in column 0, row 1 position (index 1)
         * @param {number} m10 Component in column 1, row 0 position (index 2)
         * @param {number} m11 Component in column 1, row 1 position (index 3)
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span>(out: mat2, m00: <span class="hljs-built_in">number</span>, m01: <span class="hljs-built_in">number</span>, m10: <span class="hljs-built_in">number</span>, m11: <span class="hljs-built_in">number</span>): mat2;

        <span class="hljs-comment">/**
         * Transpose the values of a mat2
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transpose(out: mat2, a: mat2): mat2;

        <span class="hljs-comment">/**
         * Inverts a mat2
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> invert(out: mat2, a: mat2): mat2 | <span class="hljs-literal">null</span>;

        <span class="hljs-comment">/**
         * Calculates the adjugate of a mat2
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> adjoint(out: mat2, a: mat2): mat2;

        <span class="hljs-comment">/**
         * Calculates the determinant of a mat2
         *
         * @param a the source matrix
         * @returns determinant of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> determinant(a: mat2): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Multiplies two mat2's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: mat2, a: mat2, b: mat2): mat2;

        <span class="hljs-comment">/**
         * Multiplies two mat2's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: mat2, a: mat2, b: mat2): mat2;

        <span class="hljs-comment">/**
         * Rotates a mat2 by the given angle
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param rad the angle to rotate the matrix by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotate(out: mat2, a: mat2, rad: <span class="hljs-built_in">number</span>): mat2;

        <span class="hljs-comment">/**
         * Scales the mat2 by the dimensions in the given vec2
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param v the vec2 to scale the matrix by
         * @returns out
         **/</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: mat2, a: mat2, v: vec2 | <span class="hljs-built_in">number</span>[]): mat2;

        <span class="hljs-comment">/**
         * Creates a matrix from a given angle
         * This is equivalent to (but much faster than):
         *
         *     mat2.identity(dest);
         *     mat2.rotate(dest, dest, rad);
         *
         * @param {mat2} out mat2 receiving operation result
         * @param {number} rad the angle to rotate the matrix by
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromRotation(out: mat2, rad: <span class="hljs-built_in">number</span>): mat2;

        <span class="hljs-comment">/**
         * Creates a matrix from a vector scaling
         * This is equivalent to (but much faster than):
         *
         *     mat2.identity(dest);
         *     mat2.scale(dest, dest, vec);
         *
         * @param {mat2} out mat2 receiving operation result
         * @param {vec2} v Scaling vector
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromScaling(out: mat2, v: vec2 | <span class="hljs-built_in">number</span>[]): mat2;

        <span class="hljs-comment">/**
         * Returns a string representation of a mat2
         *
         * @param a matrix to represent as a string
         * @returns string representation of the matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(a: mat2): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Returns Frobenius norm of a mat2
         *
         * @param a the matrix to calculate Frobenius norm of
         * @returns Frobenius norm
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> frob(a: mat2): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
         * @param L the lower triangular matrix
         * @param D the diagonal matrix
         * @param U the upper triangular matrix
         * @param a the input matrix to factorize
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LDU(L: mat2, D: mat2, U: mat2, a: mat2): mat2;

        <span class="hljs-comment">/**
         * Adds two mat2's
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the first operand
         * @param {mat2} b the second operand
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add(out: mat2, a: mat2, b: mat2): mat2;

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the first operand
         * @param {mat2} b the second operand
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> subtract (out: mat2, a: mat2, b: mat2): mat2;

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the first operand
         * @param {mat2} b the second operand
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sub (out: mat2, a: mat2, b: mat2): mat2;

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
         *
         * @param {mat2} a The first matrix.
         * @param {mat2} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals (a: mat2, b: mat2): <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have approximately the same elements in the same position.
         *
         * @param {mat2} a The first matrix.
         * @param {mat2} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals (a: mat2, b: mat2): <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Multiply each element of the matrix by a scalar.
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the matrix to scale
         * @param {number} b amount to scale the matrix's elements by
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalar (out: mat2, a: mat2, b: <span class="hljs-built_in">number</span>): mat2

        <span class="hljs-comment">/**
         * Adds two mat2's after multiplying each element of the second operand by a scalar value.
         *
         * @param {mat2} out the receiving vector
         * @param {mat2} a the first operand
         * @param {mat2} b the second operand
         * @param {number} scale the amount to scale b's elements by before adding
         * @returns {mat2} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalarAndAdd (out: mat2, a: mat2, b: mat2, scale: <span class="hljs-built_in">number</span>): mat2



    }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>mat2d</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> mat2d <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeMat2d: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new identity mat2d
         *
         * @returns a new 2x3 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): mat2d;

        <span class="hljs-comment">/**
         * Creates a new mat2d initialized with values from an existing matrix
         *
         * @param a matrix to clone
         * @returns a new 2x3 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: mat2d): mat2d;

        <span class="hljs-comment">/**
         * Copy the values from one mat2d to another
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: mat2d, a: mat2d): mat2d;

        <span class="hljs-comment">/**
         * Set a mat2d to the identity matrix
         *
         * @param out the receiving matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identity(out: mat2d): mat2d;

        <span class="hljs-comment">/**
         * Create a new mat2d with the given values
         *
         * @param {number} a Component A (index 0)
         * @param {number} b Component B (index 1)
         * @param {number} c Component C (index 2)
         * @param {number} d Component D (index 3)
         * @param {number} tx Component TX (index 4)
         * @param {number} ty Component TY (index 5)
         * @returns {mat2d} A new mat2d
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues (a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>, c: <span class="hljs-built_in">number</span>, d: <span class="hljs-built_in">number</span>, tx: <span class="hljs-built_in">number</span>, ty: <span class="hljs-built_in">number</span>): mat2d


        <span class="hljs-comment">/**
         * Set the components of a mat2d to the given values
         *
         * @param {mat2d} out the receiving matrix
         * @param {number} a Component A (index 0)
         * @param {number} b Component B (index 1)
         * @param {number} c Component C (index 2)
         * @param {number} d Component D (index 3)
         * @param {number} tx Component TX (index 4)
         * @param {number} ty Component TY (index 5)
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> (out: mat2d, a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>, c: <span class="hljs-built_in">number</span>, d: <span class="hljs-built_in">number</span>, tx: <span class="hljs-built_in">number</span>, ty: <span class="hljs-built_in">number</span>): mat2d

        <span class="hljs-comment">/**
         * Inverts a mat2d
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> invert(out: mat2d, a: mat2d): mat2d | <span class="hljs-literal">null</span>;

        <span class="hljs-comment">/**
         * Calculates the determinant of a mat2d
         *
         * @param a the source matrix
         * @returns determinant of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> determinant(a: mat2d): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Multiplies two mat2d's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: mat2d, a: mat2d, b: mat2d): mat2d;

        <span class="hljs-comment">/**
         * Multiplies two mat2d's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: mat2d, a: mat2d, b: mat2d): mat2d;

        <span class="hljs-comment">/**
         * Rotates a mat2d by the given angle
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param rad the angle to rotate the matrix by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotate(out: mat2d, a: mat2d, rad: <span class="hljs-built_in">number</span>): mat2d;

        <span class="hljs-comment">/**
         * Scales the mat2d by the dimensions in the given vec2
         *
         * @param out the receiving matrix
         * @param a the matrix to translate
         * @param v the vec2 to scale the matrix by
         * @returns out
         **/</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: mat2d, a: mat2d, v: vec2 | <span class="hljs-built_in">number</span>[]): mat2d;

        <span class="hljs-comment">/**
         * Translates the mat2d by the dimensions in the given vec2
         *
         * @param out the receiving matrix
         * @param a the matrix to translate
         * @param v the vec2 to translate the matrix by
         * @returns out
         **/</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> translate(out: mat2d, a: mat2d, v: vec2 | <span class="hljs-built_in">number</span>[]): mat2d;

        <span class="hljs-comment">/**
         * Creates a matrix from a given angle
         * This is equivalent to (but much faster than):
         *
         *     mat2d.identity(dest);
         *     mat2d.rotate(dest, dest, rad);
         *
         * @param {mat2d} out mat2d receiving operation result
         * @param {number} rad the angle to rotate the matrix by
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromRotation (out: mat2d, rad: <span class="hljs-built_in">number</span>): mat2d;

        <span class="hljs-comment">/**
         * Creates a matrix from a vector scaling
         * This is equivalent to (but much faster than):
         *
         *     mat2d.identity(dest);
         *     mat2d.scale(dest, dest, vec);
         *
         * @param {mat2d} out mat2d receiving operation result
         * @param {vec2} v Scaling vector
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromScaling (out: mat2d, v: vec2 | <span class="hljs-built_in">number</span>[]): mat2d;

        <span class="hljs-comment">/**
         * Creates a matrix from a vector translation
         * This is equivalent to (but much faster than):
         *
         *     mat2d.identity(dest);
         *     mat2d.translate(dest, dest, vec);
         *
         * @param {mat2d} out mat2d receiving operation result
         * @param {vec2} v Translation vector
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromTranslation (out: mat2d, v: vec2 | <span class="hljs-built_in">number</span>[]): mat2d

        <span class="hljs-comment">/**
         * Returns a string representation of a mat2d
         *
         * @param a matrix to represent as a string
         * @returns string representation of the matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(a: mat2d): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Returns Frobenius norm of a mat2d
         *
         * @param a the matrix to calculate Frobenius norm of
         * @returns Frobenius norm
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> frob(a: mat2d): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Adds two mat2d's
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the first operand
         * @param {mat2d} b the second operand
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add (out: mat2d, a: mat2d, b: mat2d): mat2d

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the first operand
         * @param {mat2d} b the second operand
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> subtract(out: mat2d, a: mat2d, b: mat2d): mat2d

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the first operand
         * @param {mat2d} b the second operand
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sub(out: mat2d, a: mat2d, b: mat2d): mat2d

        <span class="hljs-comment">/**
         * Multiply each element of the matrix by a scalar.
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the matrix to scale
         * @param {number} b amount to scale the matrix's elements by
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalar (out: mat2d, a: mat2d, b: <span class="hljs-built_in">number</span>): mat2d;

        <span class="hljs-comment">/**
         * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
         *
         * @param {mat2d} out the receiving vector
         * @param {mat2d} a the first operand
         * @param {mat2d} b the second operand
         * @param {number} scale the amount to scale b's elements by before adding
         * @returns {mat2d} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalarAndAdd (out: mat2d, a: mat2d, b: mat2d, scale: <span class="hljs-built_in">number</span>): mat2d

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
         *
         * @param {mat2d} a The first matrix.
         * @param {mat2d} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals (a: mat2d, b: mat2d): <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have approximately the same elements in the same position.
         *
         * @param {mat2d} a The first matrix.
         * @param {mat2d} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals (a: mat2d, b: mat2d): <span class="hljs-built_in">boolean</span>
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>mat3</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> mat3 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeMat3: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new identity mat3
         *
         * @returns a new 3x3 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): mat3;

        <span class="hljs-comment">/**
         * Copies the upper-left 3x3 values into the given mat3.
         *
         * @param {mat3} out the receiving 3x3 matrix
         * @param {mat4} a   the source 4x4 matrix
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromMat4(out: mat3, a: mat4): mat3

        <span class="hljs-comment">/**
         * Creates a new mat3 initialized with values from an existing matrix
         *
         * @param a matrix to clone
         * @returns a new 3x3 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: mat3): mat3;

        <span class="hljs-comment">/**
         * Copy the values from one mat3 to another
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: mat3, a: mat3): mat3;

        <span class="hljs-comment">/**
         * Create a new mat3 with the given values
         *
         * @param {number} m00 Component in column 0, row 0 position (index 0)
         * @param {number} m01 Component in column 0, row 1 position (index 1)
         * @param {number} m02 Component in column 0, row 2 position (index 2)
         * @param {number} m10 Component in column 1, row 0 position (index 3)
         * @param {number} m11 Component in column 1, row 1 position (index 4)
         * @param {number} m12 Component in column 1, row 2 position (index 5)
         * @param {number} m20 Component in column 2, row 0 position (index 6)
         * @param {number} m21 Component in column 2, row 1 position (index 7)
         * @param {number} m22 Component in column 2, row 2 position (index 8)
         * @returns {mat3} A new mat3
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues(m00: <span class="hljs-built_in">number</span>, m01: <span class="hljs-built_in">number</span>, m02: <span class="hljs-built_in">number</span>, m10: <span class="hljs-built_in">number</span>, m11: <span class="hljs-built_in">number</span>, m12: <span class="hljs-built_in">number</span>, m20: <span class="hljs-built_in">number</span>, m21: <span class="hljs-built_in">number</span>, m22: <span class="hljs-built_in">number</span>): mat3;


        <span class="hljs-comment">/**
         * Set the components of a mat3 to the given values
         *
         * @param {mat3} out the receiving matrix
         * @param {number} m00 Component in column 0, row 0 position (index 0)
         * @param {number} m01 Component in column 0, row 1 position (index 1)
         * @param {number} m02 Component in column 0, row 2 position (index 2)
         * @param {number} m10 Component in column 1, row 0 position (index 3)
         * @param {number} m11 Component in column 1, row 1 position (index 4)
         * @param {number} m12 Component in column 1, row 2 position (index 5)
         * @param {number} m20 Component in column 2, row 0 position (index 6)
         * @param {number} m21 Component in column 2, row 1 position (index 7)
         * @param {number} m22 Component in column 2, row 2 position (index 8)
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span>(out: mat3, m00: <span class="hljs-built_in">number</span>, m01: <span class="hljs-built_in">number</span>, m02: <span class="hljs-built_in">number</span>, m10: <span class="hljs-built_in">number</span>, m11: <span class="hljs-built_in">number</span>, m12: <span class="hljs-built_in">number</span>, m20: <span class="hljs-built_in">number</span>, m21: <span class="hljs-built_in">number</span>, m22: <span class="hljs-built_in">number</span>): mat3

        <span class="hljs-comment">/**
         * Set a mat3 to the identity matrix
         *
         * @param out the receiving matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identity(out: mat3): mat3;

        <span class="hljs-comment">/**
         * Transpose the values of a mat3
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transpose(out: mat3, a: mat3): mat3;
        
         <span class="hljs-comment">/**
         * Generates a 2D projection matrix with the given bounds
         *
         * @param out the receiving matrix
         * @param width width of your gl context
         * @param height height of gl context 
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> projection(out: mat3, width: <span class="hljs-built_in">number</span>, height: <span class="hljs-built_in">number</span>): mat3;

        <span class="hljs-comment">/**
         * Inverts a mat3
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> invert(out: mat3, a: mat3): mat3 | <span class="hljs-literal">null</span>;

        <span class="hljs-comment">/**
         * Calculates the adjugate of a mat3
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> adjoint(out: mat3, a: mat3): mat3;

        <span class="hljs-comment">/**
         * Calculates the determinant of a mat3
         *
         * @param a the source matrix
         * @returns determinant of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> determinant(a: mat3): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Multiplies two mat3's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: mat3, a: mat3, b: mat3): mat3;

        <span class="hljs-comment">/**
         * Multiplies two mat3's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: mat3, a: mat3, b: mat3): mat3;


        <span class="hljs-comment">/**
         * Translate a mat3 by the given vector
         *
         * @param out the receiving matrix
         * @param a the matrix to translate
         * @param v vector to translate by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> translate(out: mat3, a: mat3, v: vec3 | <span class="hljs-built_in">number</span>[]): mat3;

        <span class="hljs-comment">/**
         * Rotates a mat3 by the given angle
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param rad the angle to rotate the matrix by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotate(out: mat3, a: mat3, rad: <span class="hljs-built_in">number</span>): mat3;

        <span class="hljs-comment">/**
         * Scales the mat3 by the dimensions in the given vec2
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param v the vec2 to scale the matrix by
         * @returns out
         **/</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: mat3, a: mat3, v: vec2 | <span class="hljs-built_in">number</span>[]): mat3;

        <span class="hljs-comment">/**
         * Creates a matrix from a vector translation
         * This is equivalent to (but much faster than):
         *
         *     mat3.identity(dest);
         *     mat3.translate(dest, dest, vec);
         *
         * @param {mat3} out mat3 receiving operation result
         * @param {vec2} v Translation vector
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromTranslation(out: mat3, v: vec2 | <span class="hljs-built_in">number</span>[]): mat3

        <span class="hljs-comment">/**
         * Creates a matrix from a given angle
         * This is equivalent to (but much faster than):
         *
         *     mat3.identity(dest);
         *     mat3.rotate(dest, dest, rad);
         *
         * @param {mat3} out mat3 receiving operation result
         * @param {number} rad the angle to rotate the matrix by
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromRotation(out: mat3, rad: <span class="hljs-built_in">number</span>): mat3

        <span class="hljs-comment">/**
         * Creates a matrix from a vector scaling
         * This is equivalent to (but much faster than):
         *
         *     mat3.identity(dest);
         *     mat3.scale(dest, dest, vec);
         *
         * @param {mat3} out mat3 receiving operation result
         * @param {vec2} v Scaling vector
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromScaling(out: mat3, v: vec2 | <span class="hljs-built_in">number</span>[]): mat3

        <span class="hljs-comment">/**
         * Copies the values from a mat2d into a mat3
         *
         * @param out the receiving matrix
         * @param {mat2d} a the matrix to copy
         * @returns out
         **/</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromMat2d(out: mat3, a: mat2d): mat3;

        <span class="hljs-comment">/**
         * Calculates a 3x3 matrix from the given quaternion
         *
         * @param out mat3 receiving operation result
         * @param q Quaternion to create matrix from
         *
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromQuat(out: mat3, q: quat): mat3;

        <span class="hljs-comment">/**
         * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
         *
         * @param out mat3 receiving operation result
         * @param a Mat4 to derive the normal matrix from
         *
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> normalFromMat4(out: mat3, a: mat4): mat3 | <span class="hljs-literal">null</span>;

        <span class="hljs-comment">/**
         * Returns a string representation of a mat3
         *
         * @param mat matrix to represent as a string
         * @returns string representation of the matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(mat: mat3): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Returns Frobenius norm of a mat3
         *
         * @param a the matrix to calculate Frobenius norm of
         * @returns Frobenius norm
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> frob(a: mat3): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Adds two mat3's
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the first operand
         * @param {mat3} b the second operand
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add(out: mat3, a: mat3, b: mat3): mat3

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the first operand
         * @param {mat3} b the second operand
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> subtract(out: mat3, a: mat3, b: mat3): mat3

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the first operand
         * @param {mat3} b the second operand
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sub(out: mat3, a: mat3, b: mat3): mat3

        <span class="hljs-comment">/**
         * Multiply each element of the matrix by a scalar.
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the matrix to scale
         * @param {number} b amount to scale the matrix's elements by
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalar(out: mat3, a: mat3, b: <span class="hljs-built_in">number</span>): mat3

        <span class="hljs-comment">/**
         * Adds two mat3's after multiplying each element of the second operand by a scalar value.
         *
         * @param {mat3} out the receiving vector
         * @param {mat3} a the first operand
         * @param {mat3} b the second operand
         * @param {number} scale the amount to scale b's elements by before adding
         * @returns {mat3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalarAndAdd(out: mat3, a: mat3, b: mat3, scale: <span class="hljs-built_in">number</span>): mat3

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
         *
         * @param {mat3} a The first matrix.
         * @param {mat3} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals(a: mat3, b: mat3): <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have approximately the same elements in the same position.
         *
         * @param {mat3} a The first matrix.
         * @param {mat3} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals(a: mat3, b: mat3): <span class="hljs-built_in">boolean</span>
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>mat4</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> mat4 <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeMat4: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new identity mat4
         *
         * @returns a new 4x4 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): mat4;

        <span class="hljs-comment">/**
         * Creates a new mat4 initialized with values from an existing matrix
         *
         * @param a matrix to clone
         * @returns a new 4x4 matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: mat4): mat4;

        <span class="hljs-comment">/**
         * Copy the values from one mat4 to another
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: mat4, a: mat4): mat4;


        <span class="hljs-comment">/**
         * Create a new mat4 with the given values
         *
         * @param {number} m00 Component in column 0, row 0 position (index 0)
         * @param {number} m01 Component in column 0, row 1 position (index 1)
         * @param {number} m02 Component in column 0, row 2 position (index 2)
         * @param {number} m03 Component in column 0, row 3 position (index 3)
         * @param {number} m10 Component in column 1, row 0 position (index 4)
         * @param {number} m11 Component in column 1, row 1 position (index 5)
         * @param {number} m12 Component in column 1, row 2 position (index 6)
         * @param {number} m13 Component in column 1, row 3 position (index 7)
         * @param {number} m20 Component in column 2, row 0 position (index 8)
         * @param {number} m21 Component in column 2, row 1 position (index 9)
         * @param {number} m22 Component in column 2, row 2 position (index 10)
         * @param {number} m23 Component in column 2, row 3 position (index 11)
         * @param {number} m30 Component in column 3, row 0 position (index 12)
         * @param {number} m31 Component in column 3, row 1 position (index 13)
         * @param {number} m32 Component in column 3, row 2 position (index 14)
         * @param {number} m33 Component in column 3, row 3 position (index 15)
         * @returns {mat4} A new mat4
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues(m00: <span class="hljs-built_in">number</span>, m01: <span class="hljs-built_in">number</span>, m02: <span class="hljs-built_in">number</span>, m03: <span class="hljs-built_in">number</span>, m10: <span class="hljs-built_in">number</span>, m11: <span class="hljs-built_in">number</span>, m12: <span class="hljs-built_in">number</span>, m13: <span class="hljs-built_in">number</span>, m20: <span class="hljs-built_in">number</span>, m21: <span class="hljs-built_in">number</span>, m22: <span class="hljs-built_in">number</span>, m23: <span class="hljs-built_in">number</span>, m30: <span class="hljs-built_in">number</span>, m31: <span class="hljs-built_in">number</span>, m32: <span class="hljs-built_in">number</span>, m33: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Set the components of a mat4 to the given values
         *
         * @param {mat4} out the receiving matrix
         * @param {number} m00 Component in column 0, row 0 position (index 0)
         * @param {number} m01 Component in column 0, row 1 position (index 1)
         * @param {number} m02 Component in column 0, row 2 position (index 2)
         * @param {number} m03 Component in column 0, row 3 position (index 3)
         * @param {number} m10 Component in column 1, row 0 position (index 4)
         * @param {number} m11 Component in column 1, row 1 position (index 5)
         * @param {number} m12 Component in column 1, row 2 position (index 6)
         * @param {number} m13 Component in column 1, row 3 position (index 7)
         * @param {number} m20 Component in column 2, row 0 position (index 8)
         * @param {number} m21 Component in column 2, row 1 position (index 9)
         * @param {number} m22 Component in column 2, row 2 position (index 10)
         * @param {number} m23 Component in column 2, row 3 position (index 11)
         * @param {number} m30 Component in column 3, row 0 position (index 12)
         * @param {number} m31 Component in column 3, row 1 position (index 13)
         * @param {number} m32 Component in column 3, row 2 position (index 14)
         * @param {number} m33 Component in column 3, row 3 position (index 15)
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span>(out: mat4, m00: <span class="hljs-built_in">number</span>, m01: <span class="hljs-built_in">number</span>, m02: <span class="hljs-built_in">number</span>, m03: <span class="hljs-built_in">number</span>, m10: <span class="hljs-built_in">number</span>, m11: <span class="hljs-built_in">number</span>, m12: <span class="hljs-built_in">number</span>, m13: <span class="hljs-built_in">number</span>, m20: <span class="hljs-built_in">number</span>, m21: <span class="hljs-built_in">number</span>, m22: <span class="hljs-built_in">number</span>, m23: <span class="hljs-built_in">number</span>, m30: <span class="hljs-built_in">number</span>, m31: <span class="hljs-built_in">number</span>, m32: <span class="hljs-built_in">number</span>, m33: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Set a mat4 to the identity matrix
         *
         * @param out the receiving matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identity(out: mat4): mat4;

        <span class="hljs-comment">/**
         * Transpose the values of a mat4
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> transpose(out: mat4, a: mat4): mat4;

        <span class="hljs-comment">/**
         * Inverts a mat4
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> invert(out: mat4, a: mat4): mat4 | <span class="hljs-literal">null</span>;

        <span class="hljs-comment">/**
         * Calculates the adjugate of a mat4
         *
         * @param out the receiving matrix
         * @param a the source matrix
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> adjoint(out: mat4, a: mat4): mat4;

        <span class="hljs-comment">/**
         * Calculates the determinant of a mat4
         *
         * @param a the source matrix
         * @returns determinant of a
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> determinant(a: mat4): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Multiplies two mat4's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: mat4, a: mat4, b: mat4): mat4;

        <span class="hljs-comment">/**
         * Multiplies two mat4's
         *
         * @param out the receiving matrix
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: mat4, a: mat4, b: mat4): mat4;

        <span class="hljs-comment">/**
         * Translate a mat4 by the given vector
         *
         * @param out the receiving matrix
         * @param a the matrix to translate
         * @param v vector to translate by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> translate(out: mat4, a: mat4, v: vec3 | <span class="hljs-built_in">number</span>[]): mat4;

        <span class="hljs-comment">/**
         * Scales the mat4 by the dimensions in the given vec3
         *
         * @param out the receiving matrix
         * @param a the matrix to scale
         * @param v the vec3 to scale the matrix by
         * @returns out
         **/</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: mat4, a: mat4, v: vec3 | <span class="hljs-built_in">number</span>[]): mat4;

        <span class="hljs-comment">/**
         * Rotates a mat4 by the given angle
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param rad the angle to rotate the matrix by
         * @param axis the axis to rotate around
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotate(out: mat4, a: mat4, rad: <span class="hljs-built_in">number</span>, axis: vec3 | <span class="hljs-built_in">number</span>[]): mat4;

        <span class="hljs-comment">/**
         * Rotates a matrix by the given angle around the X axis
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param rad the angle to rotate the matrix by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateX(out: mat4, a: mat4, rad: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Rotates a matrix by the given angle around the Y axis
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param rad the angle to rotate the matrix by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateY(out: mat4, a: mat4, rad: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Rotates a matrix by the given angle around the Z axis
         *
         * @param out the receiving matrix
         * @param a the matrix to rotate
         * @param rad the angle to rotate the matrix by
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateZ(out: mat4, a: mat4, rad: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Creates a matrix from a vector translation
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.translate(dest, dest, vec);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {vec3} v Translation vector
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromTranslation(out: mat4, v: vec3 | <span class="hljs-built_in">number</span>[]): mat4

        <span class="hljs-comment">/**
         * Creates a matrix from a vector scaling
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.scale(dest, dest, vec);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {vec3} v Scaling vector
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromScaling(out: mat4, v: vec3 | <span class="hljs-built_in">number</span>[]): mat4

        <span class="hljs-comment">/**
         * Creates a matrix from a given angle around a given axis
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.rotate(dest, dest, rad, axis);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {number} rad the angle to rotate the matrix by
         * @param {vec3} axis the axis to rotate around
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromRotation(out: mat4, rad: <span class="hljs-built_in">number</span>, axis: vec3 | <span class="hljs-built_in">number</span>[]): mat4

        <span class="hljs-comment">/**
         * Creates a matrix from the given angle around the X axis
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.rotateX(dest, dest, rad);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {number} rad the angle to rotate the matrix by
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromXRotation(out: mat4, rad: <span class="hljs-built_in">number</span>): mat4

        <span class="hljs-comment">/**
         * Creates a matrix from the given angle around the Y axis
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.rotateY(dest, dest, rad);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {number} rad the angle to rotate the matrix by
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromYRotation(out: mat4, rad: <span class="hljs-built_in">number</span>): mat4


        <span class="hljs-comment">/**
         * Creates a matrix from the given angle around the Z axis
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.rotateZ(dest, dest, rad);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {number} rad the angle to rotate the matrix by
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromZRotation(out: mat4, rad: <span class="hljs-built_in">number</span>): mat4

        <span class="hljs-comment">/**
         * Creates a matrix from a quaternion rotation and vector translation
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.translate(dest, vec);
         *     var quatMat = mat4.create();
         *     quat4.toMat4(quat, quatMat);
         *     mat4.multiply(dest, quatMat);
         *
         * @param out mat4 receiving operation result
         * @param q Rotation quaternion
         * @param v Translation vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromRotationTranslation(out: mat4, q: quat, v: vec3 | <span class="hljs-built_in">number</span>[]): mat4;

        <span class="hljs-comment">/**
         * Returns the translation vector component of a transformation
         *  matrix. If a matrix is built with fromRotationTranslation,
         *  the returned vector will be the same as the translation vector
         *  originally supplied.
         * @param  {vec3} out Vector to receive translation component
         * @param  {mat4} mat Matrix to be decomposed (input)
         * @return {vec3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> getTranslation(out: vec3, mat: mat4): vec3;

        <span class="hljs-comment">/**
         * Returns the scaling factor component of a transformation matrix. 
         * If a matrix is built with fromRotationTranslationScale with a 
         * normalized Quaternion parameter, the returned vector will be 
         * the same as the scaling vector originally supplied.
         * @param {vec3} out Vector to receive scaling factor component
         * @param {mat4} mat Matrix to be decomposed (input)
         * @return {vec3} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> getScaling(out: vec3, mat: mat4): vec3;

        <span class="hljs-comment">/**
         * Returns a quaternion representing the rotational component
         *  of a transformation matrix. If a matrix is built with
         *  fromRotationTranslation, the returned quaternion will be the
         *  same as the quaternion originally supplied.
         * @param {quat} out Quaternion to receive the rotation component
         * @param {mat4} mat Matrix to be decomposed (input)
         * @return {quat} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> getRotation(out: quat, mat: mat4): quat;

        <span class="hljs-comment">/**
         * Creates a matrix from a quaternion rotation, vector translation and vector scale
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.translate(dest, vec);
         *     var quatMat = mat4.create();
         *     quat4.toMat4(quat, quatMat);
         *     mat4.multiply(dest, quatMat);
         *     mat4.scale(dest, scale)
         *
         * @param out mat4 receiving operation result
         * @param q Rotation quaternion
         * @param v Translation vector
         * @param s Scaling vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromRotationTranslationScale(out: mat4, q: quat, v: vec3 | <span class="hljs-built_in">number</span>[], s: vec3 | <span class="hljs-built_in">number</span>[]): mat4;

        <span class="hljs-comment">/**
         * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.translate(dest, vec);
         *     mat4.translate(dest, origin);
         *     var quatMat = mat4.create();
         *     quat4.toMat4(quat, quatMat);
         *     mat4.multiply(dest, quatMat);
         *     mat4.scale(dest, scale)
         *     mat4.translate(dest, negativeOrigin);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {quat} q Rotation quaternion
         * @param {vec3} v Translation vector
         * @param {vec3} s Scaling vector
         * @param {vec3} o The origin vector around which to scale and rotate
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromRotationTranslationScaleOrigin(out: mat4, q: quat, v: vec3 | <span class="hljs-built_in">number</span>[], s: vec3 | <span class="hljs-built_in">number</span>[], o: vec3 | <span class="hljs-built_in">number</span>[]): mat4

        <span class="hljs-comment">/**
         * Calculates a 4x4 matrix from the given quaternion
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {quat} q Quaternion to create matrix from
         *
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromQuat(out: mat4, q: quat): mat4

        <span class="hljs-comment">/**
         * Generates a frustum matrix with the given bounds
         *
         * @param out mat4 frustum matrix will be written into
         * @param left Left bound of the frustum
         * @param right Right bound of the frustum
         * @param bottom Bottom bound of the frustum
         * @param top Top bound of the frustum
         * @param near Near bound of the frustum
         * @param far Far bound of the frustum
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> frustum(out: mat4, left: <span class="hljs-built_in">number</span>, right: <span class="hljs-built_in">number</span>,
                              bottom: <span class="hljs-built_in">number</span>, top: <span class="hljs-built_in">number</span>, near: <span class="hljs-built_in">number</span>, far: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Generates a perspective projection matrix with the given bounds
         *
         * @param out mat4 frustum matrix will be written into
         * @param fovy Vertical field of view in radians
         * @param aspect Aspect ratio. typically viewport width/height
         * @param near Near bound of the frustum
         * @param far Far bound of the frustum
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> perspective(out: mat4, fovy: <span class="hljs-built_in">number</span>, aspect: <span class="hljs-built_in">number</span>,
                                  near: <span class="hljs-built_in">number</span>, far: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Generates a perspective projection matrix with the given field of view.
         * This is primarily useful for generating projection matrices to be used
         * with the still experimental WebVR API.
         *
         * @param {mat4} out mat4 frustum matrix will be written into
         * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
         * @param {number} near Near bound of the frustum
         * @param {number} far Far bound of the frustum
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> perspectiveFromFieldOfView(out: mat4,
                                                 fov:{upDegrees: <span class="hljs-built_in">number</span>, downDegrees: <span class="hljs-built_in">number</span>, leftDegrees: <span class="hljs-built_in">number</span>, rightDegrees: <span class="hljs-built_in">number</span>},
                                                 near: <span class="hljs-built_in">number</span>, far: <span class="hljs-built_in">number</span>): mat4

        <span class="hljs-comment">/**
         * Generates a orthogonal projection matrix with the given bounds
         *
         * @param out mat4 frustum matrix will be written into
         * @param left Left bound of the frustum
         * @param right Right bound of the frustum
         * @param bottom Bottom bound of the frustum
         * @param top Top bound of the frustum
         * @param near Near bound of the frustum
         * @param far Far bound of the frustum
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ortho(out: mat4, left: <span class="hljs-built_in">number</span>, right: <span class="hljs-built_in">number</span>,
                            bottom: <span class="hljs-built_in">number</span>, top: <span class="hljs-built_in">number</span>, near: <span class="hljs-built_in">number</span>, far: <span class="hljs-built_in">number</span>): mat4;

        <span class="hljs-comment">/**
         * Generates a look-at matrix with the given eye position, focal point, and up axis
         *
         * @param out mat4 frustum matrix will be written into
         * @param eye Position of the viewer
         * @param center Point the viewer is looking at
         * @param up vec3 pointing up
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lookAt(out: mat4, eye: vec3 | <span class="hljs-built_in">number</span>[], center: vec3 | <span class="hljs-built_in">number</span>[], up: vec3 | <span class="hljs-built_in">number</span>[]): mat4;

        <span class="hljs-comment">/**
         * Returns a string representation of a mat4
         *
         * @param mat matrix to represent as a string
         * @returns string representation of the matrix
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(mat: mat4): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Returns Frobenius norm of a mat4
         *
         * @param a the matrix to calculate Frobenius norm of
         * @returns Frobenius norm
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> frob(a: mat4): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Adds two mat4's
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the first operand
         * @param {mat4} b the second operand
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add(out: mat4, a: mat4, b: mat4): mat4

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the first operand
         * @param {mat4} b the second operand
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> subtract(out: mat4, a: mat4, b: mat4): mat4

        <span class="hljs-comment">/**
         * Subtracts matrix b from matrix a
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the first operand
         * @param {mat4} b the second operand
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sub(out: mat4, a: mat4, b: mat4): mat4

        <span class="hljs-comment">/**
         * Multiply each element of the matrix by a scalar.
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the matrix to scale
         * @param {number} b amount to scale the matrix's elements by
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalar(out: mat4, a: mat4, b: <span class="hljs-built_in">number</span>): mat4

        <span class="hljs-comment">/**
         * Adds two mat4's after multiplying each element of the second operand by a scalar value.
         *
         * @param {mat4} out the receiving vector
         * @param {mat4} a the first operand
         * @param {mat4} b the second operand
         * @param {number} scale the amount to scale b's elements by before adding
         * @returns {mat4} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiplyScalarAndAdd (out: mat4, a: mat4, b: mat4, scale: <span class="hljs-built_in">number</span>): mat4

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
         *
         * @param {mat4} a The first matrix.
         * @param {mat4} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals (a: mat4, b: mat4): <span class="hljs-built_in">boolean</span>

        <span class="hljs-comment">/**
         * Returns whether or not the matrices have approximately the same elements in the same position.
         *
         * @param {mat4} a The first matrix.
         * @param {mat4} b The second matrix.
         * @returns {boolean} True if the matrices are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals (a: mat4, b: mat4): <span class="hljs-built_in">boolean</span>

    }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>quat</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> quat <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Float32Array</span> {
        <span class="hljs-keyword">private</span> typeQuat: <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a new identity quat
         *
         * @returns a new quaternion
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> create(): quat;

        <span class="hljs-comment">/**
         * Creates a new quat initialized with values from an existing quaternion
         *
         * @param a quaternion to clone
         * @returns a new quaternion
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> clone(a: quat): quat;

        <span class="hljs-comment">/**
         * Creates a new quat initialized with the given values
         *
         * @param x X component
         * @param y Y component
         * @param z Z component
         * @param w W component
         * @returns a new quaternion
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromValues(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span>, w: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Copy the values from one quat to another
         *
         * @param out the receiving quaternion
         * @param a the source quaternion
         * @returns out
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> copy(out: quat, a: quat): quat;

        <span class="hljs-comment">/**
         * Set the components of a quat to the given values
         *
         * @param out the receiving quaternion
         * @param x X component
         * @param y Y component
         * @param z Z component
         * @param w W component
         * @returns out
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span>(out: quat, x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span>, w: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Set a quat to the identity quaternion
         *
         * @param out the receiving quaternion
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> identity(out: quat): quat;

        <span class="hljs-comment">/**
         * Sets a quaternion to represent the shortest rotation from one
         * vector to another.
         *
         * Both vectors are assumed to be unit length.
         *
         * @param {quat} out the receiving quaternion.
         * @param {vec3} a the initial vector
         * @param {vec3} b the destination vector
         * @returns {quat} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotationTo (out: quat, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): quat;

        <span class="hljs-comment">/**
         * Sets the specified quaternion with values corresponding to the given
         * axes. Each axis is a vec3 and is expected to be unit length and
         * perpendicular to all other specified axes.
         *
         * @param {vec3} view  the vector representing the viewing direction
         * @param {vec3} right the vector representing the local "right" direction
         * @param {vec3} up    the vector representing the local "up" direction
         * @returns {quat} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> setAxes (out: quat, view: vec3 | <span class="hljs-built_in">number</span>[], right: vec3 | <span class="hljs-built_in">number</span>[], up: vec3 | <span class="hljs-built_in">number</span>[]): quat



        <span class="hljs-comment">/**
         * Sets a quat from the given angle and rotation axis,
         * then returns it.
         *
         * @param out the receiving quaternion
         * @param axis the axis around which to rotate
         * @param rad the angle in radians
         * @returns out
         **/</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> setAxisAngle(out: quat, axis: vec3 | <span class="hljs-built_in">number</span>[], rad: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Gets the rotation axis and angle for a given
         *  quaternion. If a quaternion is created with
         *  setAxisAngle, this method will return the same
         *  values as providied in the original parameter list
         *  OR functionally equivalent values.
         * Example: The quaternion formed by axis [0, 0, 1] and
         *  angle -90 is the same as the quaternion formed by
         *  [0, 0, 1] and 270. This method favors the latter.
         * @param  {vec3} out_axis  Vector receiving the axis of rotation
         * @param  {quat} q     Quaternion to be decomposed
         * @return {number}     Angle, in radians, of the rotation
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> getAxisAngle (out_axis: vec3 | <span class="hljs-built_in">number</span>[], q: quat): <span class="hljs-built_in">number</span>

        <span class="hljs-comment">/**
         * Adds two quat's
         *
         * @param out the receiving quaternion
         * @param a the first operand
         * @param b the second operand
         * @returns out
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> add(out: quat, a: quat, b: quat): quat;

        <span class="hljs-comment">/**
         * Multiplies two quat's
         *
         * @param out the receiving quaternion
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> multiply(out: quat, a: quat, b: quat): quat;

        <span class="hljs-comment">/**
         * Multiplies two quat's
         *
         * @param out the receiving quaternion
         * @param a the first operand
         * @param b the second operand
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> mul(out: quat, a: quat, b: quat): quat;

        <span class="hljs-comment">/**
         * Scales a quat by a scalar number
         *
         * @param out the receiving vector
         * @param a the vector to scale
         * @param b amount to scale the vector by
         * @returns out
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> scale(out: quat, a: quat, b: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Calculates the length of a quat
         *
         * @param a vector to calculate length of
         * @returns length of a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> length(a: quat): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the length of a quat
         *
         * @param a vector to calculate length of
         * @returns length of a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> len(a: quat): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a quat
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> squaredLength(a: quat): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Calculates the squared length of a quat
         *
         * @param a vector to calculate squared length of
         * @returns squared length of a
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqrLen(a: quat): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Normalize a quat
         *
         * @param out the receiving quaternion
         * @param a quaternion to normalize
         * @returns out
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> normalize(out: quat, a: quat): quat;

        <span class="hljs-comment">/**
         * Calculates the dot product of two quat's
         *
         * @param a the first operand
         * @param b the second operand
         * @returns dot product of a and b
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> dot(a: quat, b: quat): <span class="hljs-built_in">number</span>;

        <span class="hljs-comment">/**
         * Creates a quaternion from the given euler angle x, y, z.
         *
         * @param {quat} out the receiving quaternion
         * @param {number} x Angle to rotate around X axis in degrees.
         * @param {number} y Angle to rotate around Y axis in degrees.
         * @param {number} z Angle to rotate around Z axis in degrees.
         * @returns {quat} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromEuler(out: quat, x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Performs a linear interpolation between two quat's
         *
         * @param out the receiving quaternion
         * @param a the first operand
         * @param b the second operand
         * @param t interpolation amount between the two inputs
         * @returns out
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lerp(out: quat, a: quat, b: quat, t: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Performs a spherical linear interpolation between two quat
         *
         * @param out the receiving quaternion
         * @param a the first operand
         * @param b the second operand
         * @param t interpolation amount between the two inputs
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> slerp(out: quat, a: quat, b: quat, t: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Performs a spherical linear interpolation with two control points
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a the first operand
         * @param {quat} b the second operand
         * @param {quat} c the third operand
         * @param {quat} d the fourth operand
         * @param {number} t interpolation amount
         * @returns {quat} out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sqlerp(out: quat, a: quat, b: quat, c: quat, d: quat, t: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Calculates the inverse of a quat
         *
         * @param out the receiving quaternion
         * @param a quat to calculate inverse of
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> invert(out: quat, a: quat): quat;

        <span class="hljs-comment">/**
         * Calculates the conjugate of a quat
         * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
         *
         * @param out the receiving quaternion
         * @param a quat to calculate conjugate of
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> conjugate(out: quat, a: quat): quat;

        <span class="hljs-comment">/**
         * Returns a string representation of a quaternion
         *
         * @param a quat to represent as a string
         * @returns string representation of the quat
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> str(a: quat): <span class="hljs-built_in">string</span>;

        <span class="hljs-comment">/**
         * Rotates a quaternion by the given angle about the X axis
         *
         * @param out quat receiving operation result
         * @param a quat to rotate
         * @param rad angle (in radians) to rotate
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateX(out: quat, a: quat, rad: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Rotates a quaternion by the given angle about the Y axis
         *
         * @param out quat receiving operation result
         * @param a quat to rotate
         * @param rad angle (in radians) to rotate
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateY(out: quat, a: quat, rad: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Rotates a quaternion by the given angle about the Z axis
         *
         * @param out quat receiving operation result
         * @param a quat to rotate
         * @param rad angle (in radians) to rotate
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotateZ(out: quat, a: quat, rad: <span class="hljs-built_in">number</span>): quat;

        <span class="hljs-comment">/**
         * Creates a quaternion from the given 3x3 rotation matrix.
         *
         * <span class="hljs-doctag">NOTE:</span> The resultant quaternion is not normalized, so you should be sure
         * to renormalize the quaternion yourself where necessary.
         *
         * @param out the receiving quaternion
         * @param m rotation matrix
         * @returns out
         * @function
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fromMat3(out: quat, m: mat3): quat;

        <span class="hljs-comment">/**
         * Sets the specified quaternion with values corresponding to the given
         * axes. Each axis is a vec3 and is expected to be unit length and
         * perpendicular to all other specified axes.
         *
         * @param out the receiving quat
         * @param view  the vector representing the viewing direction
         * @param right the vector representing the local "right" direction
         * @param up    the vector representing the local "up" direction
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> setAxes(out: quat, view: vec3 | <span class="hljs-built_in">number</span>[], right: vec3 | <span class="hljs-built_in">number</span>[], up: vec3 | <span class="hljs-built_in">number</span>[]): quat;

        <span class="hljs-comment">/**
         * Sets a quaternion to represent the shortest rotation from one
         * vector to another.
         *
         * Both vectors are assumed to be unit length.
         *
         * @param out the receiving quaternion.
         * @param a the initial vector
         * @param b the destination vector
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> rotationTo(out: quat, a: vec3 | <span class="hljs-built_in">number</span>[], b: vec3 | <span class="hljs-built_in">number</span>[]): quat;

        <span class="hljs-comment">/**
         * Calculates the W component of a quat from the X, Y, and Z components.
         * Assumes that quaternion is 1 unit in length.
         * Any existing W component will be ignored.
         *
         * @param out the receiving quaternion
         * @param a quat to calculate W component of
         * @returns out
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> calculateW(out: quat, a: quat): quat;

        <span class="hljs-comment">/**
         * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
         *
         * @param {quat} a The first vector.
         * @param {quat} b The second vector.
         * @returns {boolean} True if the quaternions are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> exactEquals (a: quat, b: quat): <span class="hljs-built_in">boolean</span>;

        <span class="hljs-comment">/**
         * Returns whether or not the quaternions have approximately the same elements in the same position.
         *
         * @param {quat} a The first vector.
         * @param {quat} b The second vector.
         * @returns {boolean} True if the quaternions are equal, false otherwise.
         */</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> equals (a: quat, b: quat): <span class="hljs-built_in">boolean</span>;
    }
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/common' {
    <span class="hljs-keyword">import</span> { glMatrix } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = glMatrix;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/vec2' {
    <span class="hljs-keyword">import</span> { vec2 } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = vec2;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/vec3' {
    <span class="hljs-keyword">import</span> { vec3 } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = vec3;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/vec4' {
    <span class="hljs-keyword">import</span> { vec4 } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = vec4;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/mat2' {
    <span class="hljs-keyword">import</span> { mat2 } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = mat2;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/mat2d' {
    <span class="hljs-keyword">import</span> { mat2d } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = mat2d;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/mat3' {
    <span class="hljs-keyword">import</span> { mat3 } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = mat3;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/mat4' {
    <span class="hljs-keyword">import</span> { mat4 } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = mat4;
}

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> 'gl-matrix/src/gl-matrix/quat' {
    <span class="hljs-keyword">import</span> { quat } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span>;
    <span class="hljs-keyword">export</span> = quat;
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
